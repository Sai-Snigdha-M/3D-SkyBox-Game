<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Cube Jump Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #gameOverScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            color: red;
            text-align: center;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #gameOverScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: red;
        }

        #gameOverScreen p {
            font-size: 24px;
            margin-bottom: 30px;
            color: red;
        }

        #restartButton {
            background-color: red;
            border: 2px solid white;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        #restartButton:hover {
            background-color: darkred;
            transform: scale(1.1);
        }

        #score {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            font-family: Arial, sans-serif;
            z-index: 1000;
        }
    </style>
</head>

<body>
    <div id="score">Score: <span id="scoreValue">0</span></div>
    <div id="gameOverScreen">
        <h1>Game Over!</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restartButton">Restart Game</button>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();

        // Create skybox
        const skyboxLoader = new THREE.CubeTextureLoader();
        const skybox = skyboxLoader.load([
            'https://devday2.s3.ap-south-1.amazonaws.com/Rainforest/px.png',
            'https://devday2.s3.ap-south-1.amazonaws.com/Rainforest/nx.png',
            'https://devday2.s3.ap-south-1.amazonaws.com/Rainforest/py.png',
            'https://devday2.s3.ap-south-1.amazonaws.com/Rainforest/ny.png',
            'https://devday2.s3.ap-south-1.amazonaws.com/Rainforest/pz.png',
            'https://devday2.s3.ap-south-1.amazonaws.com/Rainforest/nz.png'
        ]);
        scene.background = skybox;

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Platform
        const platformGeometry = new THREE.BoxGeometry(10, 1, 50);
        const platformMaterial = new THREE.MeshPhongMaterial({ color: 0xF0FFFF }); // Azure white color
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.y = -0.5;
        platform.receiveShadow = true;
        scene.add(platform);

        // Player
        function createPlayer() {
            const player = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.3, 0.5, 4, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x2194ce });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            player.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xffd700 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.1;
            head.castShadow = true;
            player.add(head);

            // Arms
            const armGeometry = new THREE.CapsuleGeometry(0.1, 0.4, 4, 8);
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0x2194ce });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 0.5, 0);
            leftArm.castShadow = true;
            player.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4, 0.5, 0);
            rightArm.castShadow = true;
            player.add(rightArm);

            // Legs
            const legGeometry = new THREE.CapsuleGeometry(0.12, 0.4, 4, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x1e90ff });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, 0, 0);
            leftLeg.castShadow = true;
            player.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, 0, 0);
            rightLeg.castShadow = true;
            player.add(rightLeg);

            return player;
        }

        const player = createPlayer();
        player.position.set(0, 1, 0);
        scene.add(player);

        // Player physics
        const playerState = {
            velocity: new THREE.Vector3(),
            onGround: true,
            jumpForce: 0.2,
            gravity: -0.01,
            isGameOver: false
        };

        // Game state
        let score = 0;
        let gameStartTime = Date.now();

        // Function to update score
        function updateScore() {
            if (!playerState.isGameOver) {
                score = Math.floor((Date.now() - gameStartTime) / 1000);
                document.getElementById('scoreValue').textContent = score;
            }
        }

        // Function to handle game over
        function gameOver() {
            playerState.isGameOver = true;
            document.getElementById('gameOverScreen').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
        }

        // Function to restart game
        function restartGame() {
            // Reset player position
            player.position.set(0, 1, 0);
            playerState.velocity.set(0, 0, 0);
            playerState.isGameOver = false;
            playerState.onGround = true;

            // Clear obstacles
            obstacles.forEach(obstacle => {
                scene.remove(obstacle);
            });
            obstacles.length = 0;

            // Reset score
            score = 0;
            gameStartTime = Date.now();
            document.getElementById('scoreValue').textContent = '0';
            document.getElementById('gameOverScreen').style.display = 'none';
        }

        // Add event listener for restart button
        document.getElementById('restartButton').addEventListener('click', restartGame);

        // Obstacles array
        const obstacles = [];

        // Create football texture
        const textureLoader = new THREE.TextureLoader();
        const footballTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');

        // Create a more interesting geometry for obstacles
        const obstacleGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const obstacleMaterial = new THREE.MeshPhongMaterial({
            map: footballTexture,
            bumpMap: footballTexture,
            bumpScale: 0.02,
            shininess: 5
        });

        // Spawn obstacles
        function spawnObstacle() {
            if (!playerState.isGameOver) {
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.position.set(0, 1, -45); // Start far back
                obstacle.castShadow = true;
                // Add rotation property
                obstacle.rotation.x = Math.random() * Math.PI;
                obstacle.rotation.y = Math.random() * Math.PI;
                scene.add(obstacle);
                obstacles.push(obstacle);
            }
        }

        // Spawn obstacles periodically
        setInterval(spawnObstacle, 2000);

        // Handle keyboard input
        const keys = {};
        document.addEventListener('keydown', (e) => {
            if (playerState.isGameOver) return;
            keys[e.code] = true;
            if ((e.code === 'Space' || e.code === 'ArrowUp') && playerState.onGround) {
                playerState.velocity.y = playerState.jumpForce;
                playerState.onGround = false;
            }
        });
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update player physics
            playerState.velocity.y += playerState.gravity;
            player.position.y += playerState.velocity.y;

            // Ground collision
            if (player.position.y < 1) {
                player.position.y = 1;
                playerState.velocity.y = 0;
                playerState.onGround = true;
            }

            // Update obstacles
            obstacles.forEach((obstacle, index) => {
                if (playerState.isGameOver) return;

                // Add rotation animation
                obstacle.rotation.x += 0.02;
                obstacle.rotation.y += 0.02;

                // Move towards player's x position smoothly
                const xDiff = player.position.x - obstacle.position.x;
                obstacle.position.x += xDiff * 0.03; // Smooth following effect
                obstacle.position.z += 0.2; // Move towards player

                // Remove obstacles that pass the player
                if (obstacle.position.z > 5) {
                    scene.remove(obstacle);
                    obstacles.splice(index, 1);
                }

                // Improved collision detection with smaller threshold
                const collisionThreshold = 0.6; // Adjusted for spherical shape
                if (Math.abs(obstacle.position.x - player.position.x) < collisionThreshold &&
                    Math.abs(obstacle.position.y - player.position.y) < collisionThreshold &&
                    Math.abs(obstacle.position.z - player.position.z) < collisionThreshold) {
                    if (!playerState.isGameOver) {
                        gameOver();
                    }
                }
            });

            // Update score
            updateScore();

            // Left/Right movement
            if (!playerState.isGameOver) {
                if (keys['ArrowLeft']) player.position.x -= 0.1;
                if (keys['ArrowRight']) player.position.x += 0.1;
            }

            // Keep player within bounds
            player.position.x = Math.max(-4, Math.min(4, player.position.x));

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>